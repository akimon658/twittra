/**
 * Generated by orval v7.18.0 üç∫
 * Do not edit manually.
 * Twittra
 * OpenAPI spec version: 0.1.0
 */
import { useMutation } from "@tanstack/react-query"
import type {
  MutationFunction,
  UseMutationOptions,
  UseMutationResult,
} from "@tanstack/react-query"

import type { ReadMessagesRequest } from "../twittra.schemas"

import { customReviver } from ".././reviver"

type AwaitedInput<T> = PromiseLike<T> | T

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

export type markMessagesAsReadResponse204 = {
  data: void
  status: 204
}

export type markMessagesAsReadResponse401 = {
  data: void
  status: 401
}

export type markMessagesAsReadResponse500 = {
  data: void
  status: 500
}

export type markMessagesAsReadResponseSuccess =
  & (markMessagesAsReadResponse204)
  & {
    headers: Headers
  }
export type markMessagesAsReadResponseError =
  & (markMessagesAsReadResponse401 | markMessagesAsReadResponse500)
  & {
    headers: Headers
  }

export const getMarkMessagesAsReadUrl = () => {
  return `/api/v1/messages/read`
}

export const markMessagesAsRead = async (
  readMessagesRequest: ReadMessagesRequest,
  options?: RequestInit,
): Promise<markMessagesAsReadResponseSuccess> => {
  const res = await fetch(getMarkMessagesAsReadUrl(), {
    ...options,
    method: "POST",
    headers: { "Content-Type": "application/json", ...options?.headers },
    body: JSON.stringify(
      readMessagesRequest,
    ),
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  if (!res.ok) {
    const err: globalThis.Error & {
      info?: markMessagesAsReadResponseError["data"]
      status?: number
    } = new globalThis.Error()
    const data: markMessagesAsReadResponseError["data"] = body
      ? JSON.parse(body, customReviver)
      : {}
    err.info = data
    err.status = res.status
    throw err
  }
  const data: markMessagesAsReadResponseSuccess["data"] = body
    ? JSON.parse(body, customReviver)
    : {}
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as markMessagesAsReadResponseSuccess
}

export const getMarkMessagesAsReadMutationOptions = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markMessagesAsRead>>,
      TError,
      { data: ReadMessagesRequest },
      TContext
    >
    fetch?: RequestInit
  },
): UseMutationOptions<
  Awaited<ReturnType<typeof markMessagesAsRead>>,
  TError,
  { data: ReadMessagesRequest },
  TContext
> => {
  const mutationKey = ["markMessagesAsRead"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && "mutationKey" in options.mutation &&
        options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof markMessagesAsRead>>,
    { data: ReadMessagesRequest }
  > = (props) => {
    const { data } = props ?? {}

    return markMessagesAsRead(data, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type MarkMessagesAsReadMutationResult = NonNullable<
  Awaited<ReturnType<typeof markMessagesAsRead>>
>
export type MarkMessagesAsReadMutationBody = ReadMessagesRequest
export type MarkMessagesAsReadMutationError = void

export const useMarkMessagesAsRead = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof markMessagesAsRead>>,
      TError,
      { data: ReadMessagesRequest },
      TContext
    >
    fetch?: RequestInit
  },
): UseMutationResult<
  Awaited<ReturnType<typeof markMessagesAsRead>>,
  TError,
  { data: ReadMessagesRequest },
  TContext
> => {
  const mutationOptions = getMarkMessagesAsReadMutationOptions(options)

  return useMutation(mutationOptions)
}
export type addMessageStampResponse204 = {
  data: void
  status: 204
}

export type addMessageStampResponse401 = {
  data: void
  status: 401
}

export type addMessageStampResponse500 = {
  data: void
  status: 500
}

export type addMessageStampResponseSuccess = (addMessageStampResponse204) & {
  headers: Headers
}
export type addMessageStampResponseError =
  & (addMessageStampResponse401 | addMessageStampResponse500)
  & {
    headers: Headers
  }

export const getAddMessageStampUrl = (messageId: string, stampId: string) => {
  return `/api/v1/messages/${messageId}/stamps/${stampId}`
}

export const addMessageStamp = async (
  messageId: string,
  stampId: string,
  options?: RequestInit,
): Promise<addMessageStampResponseSuccess> => {
  const res = await fetch(getAddMessageStampUrl(messageId, stampId), {
    ...options,
    method: "POST",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  if (!res.ok) {
    const err: globalThis.Error & {
      info?: addMessageStampResponseError["data"]
      status?: number
    } = new globalThis.Error()
    const data: addMessageStampResponseError["data"] = body
      ? JSON.parse(body, customReviver)
      : {}
    err.info = data
    err.status = res.status
    throw err
  }
  const data: addMessageStampResponseSuccess["data"] = body
    ? JSON.parse(body, customReviver)
    : {}
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as addMessageStampResponseSuccess
}

export const getAddMessageStampMutationOptions = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addMessageStamp>>,
      TError,
      { messageId: string; stampId: string },
      TContext
    >
    fetch?: RequestInit
  },
): UseMutationOptions<
  Awaited<ReturnType<typeof addMessageStamp>>,
  TError,
  { messageId: string; stampId: string },
  TContext
> => {
  const mutationKey = ["addMessageStamp"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && "mutationKey" in options.mutation &&
        options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof addMessageStamp>>,
    { messageId: string; stampId: string }
  > = (props) => {
    const { messageId, stampId } = props ?? {}

    return addMessageStamp(messageId, stampId, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type AddMessageStampMutationResult = NonNullable<
  Awaited<ReturnType<typeof addMessageStamp>>
>

export type AddMessageStampMutationError = void

export const useAddMessageStamp = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addMessageStamp>>,
      TError,
      { messageId: string; stampId: string },
      TContext
    >
    fetch?: RequestInit
  },
): UseMutationResult<
  Awaited<ReturnType<typeof addMessageStamp>>,
  TError,
  { messageId: string; stampId: string },
  TContext
> => {
  const mutationOptions = getAddMessageStampMutationOptions(options)

  return useMutation(mutationOptions)
}
export type removeMessageStampResponse204 = {
  data: void
  status: 204
}

export type removeMessageStampResponse401 = {
  data: void
  status: 401
}

export type removeMessageStampResponse500 = {
  data: void
  status: 500
}

export type removeMessageStampResponseSuccess =
  & (removeMessageStampResponse204)
  & {
    headers: Headers
  }
export type removeMessageStampResponseError =
  & (removeMessageStampResponse401 | removeMessageStampResponse500)
  & {
    headers: Headers
  }

export const getRemoveMessageStampUrl = (
  messageId: string,
  stampId: string,
) => {
  return `/api/v1/messages/${messageId}/stamps/${stampId}`
}

export const removeMessageStamp = async (
  messageId: string,
  stampId: string,
  options?: RequestInit,
): Promise<removeMessageStampResponseSuccess> => {
  const res = await fetch(getRemoveMessageStampUrl(messageId, stampId), {
    ...options,
    method: "DELETE",
  })

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  if (!res.ok) {
    const err: globalThis.Error & {
      info?: removeMessageStampResponseError["data"]
      status?: number
    } = new globalThis.Error()
    const data: removeMessageStampResponseError["data"] = body
      ? JSON.parse(body, customReviver)
      : {}
    err.info = data
    err.status = res.status
    throw err
  }
  const data: removeMessageStampResponseSuccess["data"] = body
    ? JSON.parse(body, customReviver)
    : {}
  return {
    data,
    status: res.status,
    headers: res.headers,
  } as removeMessageStampResponseSuccess
}

export const getRemoveMessageStampMutationOptions = <
  TError = void,
  TContext = unknown,
>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeMessageStamp>>,
      TError,
      { messageId: string; stampId: string },
      TContext
    >
    fetch?: RequestInit
  },
): UseMutationOptions<
  Awaited<ReturnType<typeof removeMessageStamp>>,
  TError,
  { messageId: string; stampId: string },
  TContext
> => {
  const mutationKey = ["removeMessageStamp"]
  const { mutation: mutationOptions, fetch: fetchOptions } = options
    ? options.mutation && "mutationKey" in options.mutation &&
        options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, fetch: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof removeMessageStamp>>,
    { messageId: string; stampId: string }
  > = (props) => {
    const { messageId, stampId } = props ?? {}

    return removeMessageStamp(messageId, stampId, fetchOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type RemoveMessageStampMutationResult = NonNullable<
  Awaited<ReturnType<typeof removeMessageStamp>>
>

export type RemoveMessageStampMutationError = void

export const useRemoveMessageStamp = <TError = void, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof removeMessageStamp>>,
      TError,
      { messageId: string; stampId: string },
      TContext
    >
    fetch?: RequestInit
  },
): UseMutationResult<
  Awaited<ReturnType<typeof removeMessageStamp>>,
  TError,
  { messageId: string; stampId: string },
  TContext
> => {
  const mutationOptions = getRemoveMessageStampMutationOptions(options)

  return useMutation(mutationOptions)
}
