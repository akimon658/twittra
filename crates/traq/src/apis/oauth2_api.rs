/*
 * traQ v3
 *
 * traQ v3 API
 *
 * The version of the OpenAPI document: 3.0
 *
 * Generated by: https://openapi-generator.tech
 */

use super::{configuration, ContentType, Error};
use crate::{apis::ResponseContent, models};
use reqwest;
use serde::{de::Error as _, Deserialize, Serialize};

/// struct for typed errors of method [`create_client`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateClientError {
    Status400(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_client`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteClientError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`edit_client`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum EditClientError {
    Status400(),
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_client`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClientError {
    Status403(),
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_clients`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClientsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_my_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetMyTokensError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_o_auth2_authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOAuth2AuthorizeError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_o_auth2_authorize`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostOAuth2AuthorizeError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_o_auth2_authorize_decide`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostOAuth2AuthorizeDecideError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`post_o_auth2_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum PostOAuth2TokenError {
    Status400(),
    Status403(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_client_tokens`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeClientTokensError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_my_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeMyTokenError {
    Status404(),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`revoke_o_auth2_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RevokeOAuth2TokenError {
    UnknownValue(serde_json::Value),
}

/// OAuth2クライアントを作成します。
pub async fn create_client(
    configuration: &configuration::Configuration,
    post_client_request: Option<models::PostClientRequest>,
) -> Result<models::OAuth2ClientDetail, Error<CreateClientError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_post_client_request = post_client_request;

    let uri_str = format!("{}/clients", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_post_client_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuth2ClientDetail`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuth2ClientDetail`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateClientError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 指定したOAuth2クライアントを削除します。 対象のクライアントの管理権限が必要です。正常に削除された場合、このクライアントに対する認可は全て取り消されます。
pub async fn delete_client(
    configuration: &configuration::Configuration,
    client_id: &str,
) -> Result<(), Error<DeleteClientError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;

    let uri_str = format!(
        "{}/clients/{clientId}",
        configuration.base_path,
        clientId = crate::apis::urlencode(p_path_client_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteClientError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 指定したOAuth2クライアントの情報を変更します。 対象のクライアントの管理権限が必要です。 クライアント開発者UUIDを変更した場合は、変更先ユーザーにクライアント管理権限が移譲され、自分自身は権限を失います。
pub async fn edit_client(
    configuration: &configuration::Configuration,
    client_id: &str,
    patch_client_request: Option<models::PatchClientRequest>,
) -> Result<(), Error<EditClientError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;
    let p_body_patch_client_request = patch_client_request;

    let uri_str = format!(
        "{}/clients/{clientId}",
        configuration.base_path,
        clientId = crate::apis::urlencode(p_path_client_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::PATCH, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_patch_client_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<EditClientError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 指定したOAuth2クライアントの情報を取得します。 詳細情報の取得には対象のクライアントの管理権限が必要です。
pub async fn get_client(
    configuration: &configuration::Configuration,
    client_id: &str,
    detail: Option<bool>,
) -> Result<models::GetClient200Response, Error<GetClientError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;
    let p_query_detail = detail;

    let uri_str = format!(
        "{}/clients/{clientId}",
        configuration.base_path,
        clientId = crate::apis::urlencode(p_path_client_id)
    );
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_detail {
        req_builder = req_builder.query(&[("detail", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetClient200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetClient200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClientError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 自身が開発者のOAuth2クライアントのリストを取得します。 `all`が`true`の場合、全開発者の全クライアントのリストを返します。
pub async fn get_clients(
    configuration: &configuration::Configuration,
    all: Option<bool>,
) -> Result<Vec<models::OAuth2Client>, Error<GetClientsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_all = all;

    let uri_str = format!("{}/clients", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_all {
        req_builder = req_builder.query(&[("all", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::OAuth2Client&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::OAuth2Client&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClientsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 有効な自分に発行されたOAuth2トークンのリストを取得します。
pub async fn get_my_tokens(
    configuration: &configuration::Configuration,
) -> Result<Vec<models::ActiveOAuth2Token>, Error<GetMyTokensError>> {
    let uri_str = format!("{}/users/me/tokens", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ActiveOAuth2Token&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ActiveOAuth2Token&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetMyTokensError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuth2 認可エンドポイント
pub async fn get_o_auth2_authorize(
    configuration: &configuration::Configuration,
    client_id: &str,
    response_type: Option<models::OAuth2ResponseType>,
    redirect_uri: Option<&str>,
    scope: Option<&str>,
    state: Option<&str>,
    code_challenge: Option<&str>,
    code_challenge_method: Option<&str>,
    nonce: Option<&str>,
    prompt: Option<models::OAuth2Prompt>,
) -> Result<(), Error<GetOAuth2AuthorizeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_client_id = client_id;
    let p_query_response_type = response_type;
    let p_query_redirect_uri = redirect_uri;
    let p_query_scope = scope;
    let p_query_state = state;
    let p_query_code_challenge = code_challenge;
    let p_query_code_challenge_method = code_challenge_method;
    let p_query_nonce = nonce;
    let p_query_prompt = prompt;

    let uri_str = format!("{}/oauth2/authorize", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_response_type {
        req_builder = req_builder.query(&[("response_type", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("client_id", &p_query_client_id.to_string())]);
    if let Some(ref param_value) = p_query_redirect_uri {
        req_builder = req_builder.query(&[("redirect_uri", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_scope {
        req_builder = req_builder.query(&[("scope", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_state {
        req_builder = req_builder.query(&[("state", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_code_challenge {
        req_builder = req_builder.query(&[("code_challenge", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_code_challenge_method {
        req_builder = req_builder.query(&[("code_challenge_method", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_nonce {
        req_builder = req_builder.query(&[("nonce", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_prompt {
        req_builder = req_builder.query(&[("prompt", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<GetOAuth2AuthorizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuth2 認可エンドポイント
pub async fn post_o_auth2_authorize(
    configuration: &configuration::Configuration,
    client_id: &str,
    response_type: Option<crate::models::OAuth2ResponseType>,
    redirect_uri: Option<&str>,
    scope: Option<&str>,
    state: Option<&str>,
    code_challenge: Option<&str>,
    code_challenge_method: Option<&str>,
    nonce: Option<&str>,
    prompt: Option<crate::models::OAuth2Prompt>,
) -> Result<(), Error<PostOAuth2AuthorizeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_client_id = client_id;
    let p_form_response_type = response_type;
    let p_form_redirect_uri = redirect_uri;
    let p_form_scope = scope;
    let p_form_state = state;
    let p_form_code_challenge = code_challenge;
    let p_form_code_challenge_method = code_challenge_method;
    let p_form_nonce = nonce;
    let p_form_prompt = prompt;

    let uri_str = format!("{}/oauth2/authorize", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = p_form_response_type {
        multipart_form_params.insert("response_type", param_value.to_string());
    }
    multipart_form_params.insert("client_id", p_form_client_id.to_string());
    if let Some(param_value) = p_form_redirect_uri {
        multipart_form_params.insert("redirect_uri", param_value.to_string());
    }
    if let Some(param_value) = p_form_scope {
        multipart_form_params.insert("scope", param_value.to_string());
    }
    if let Some(param_value) = p_form_state {
        multipart_form_params.insert("state", param_value.to_string());
    }
    if let Some(param_value) = p_form_code_challenge {
        multipart_form_params.insert("code_challenge", param_value.to_string());
    }
    if let Some(param_value) = p_form_code_challenge_method {
        multipart_form_params.insert("code_challenge_method", param_value.to_string());
    }
    if let Some(param_value) = p_form_nonce {
        multipart_form_params.insert("nonce", param_value.to_string());
    }
    if let Some(param_value) = p_form_prompt {
        multipart_form_params.insert("prompt", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostOAuth2AuthorizeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuth2 認可承諾
pub async fn post_o_auth2_authorize_decide(
    configuration: &configuration::Configuration,
    submit: &str,
) -> Result<(), Error<PostOAuth2AuthorizeDecideError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_submit = submit;

    let uri_str = format!("{}/oauth2/authorize/decide", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("submit", p_form_submit.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<PostOAuth2AuthorizeDecideError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuth2 トークンエンドポイント
pub async fn post_o_auth2_token(
    configuration: &configuration::Configuration,
    grant_type: &str,
    code: Option<&str>,
    redirect_uri: Option<&str>,
    client_id: Option<&str>,
    code_verifier: Option<&str>,
    username: Option<&str>,
    password: Option<&str>,
    scope: Option<&str>,
    refresh_token: Option<&str>,
    client_secret: Option<&str>,
) -> Result<models::OAuth2Token, Error<PostOAuth2TokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_grant_type = grant_type;
    let p_form_code = code;
    let p_form_redirect_uri = redirect_uri;
    let p_form_client_id = client_id;
    let p_form_code_verifier = code_verifier;
    let p_form_username = username;
    let p_form_password = password;
    let p_form_scope = scope;
    let p_form_refresh_token = refresh_token;
    let p_form_client_secret = client_secret;

    let uri_str = format!("{}/oauth2/token", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("grant_type", p_form_grant_type.to_string());
    if let Some(param_value) = p_form_code {
        multipart_form_params.insert("code", param_value.to_string());
    }
    if let Some(param_value) = p_form_redirect_uri {
        multipart_form_params.insert("redirect_uri", param_value.to_string());
    }
    if let Some(param_value) = p_form_client_id {
        multipart_form_params.insert("client_id", param_value.to_string());
    }
    if let Some(param_value) = p_form_code_verifier {
        multipart_form_params.insert("code_verifier", param_value.to_string());
    }
    if let Some(param_value) = p_form_username {
        multipart_form_params.insert("username", param_value.to_string());
    }
    if let Some(param_value) = p_form_password {
        multipart_form_params.insert("password", param_value.to_string());
    }
    if let Some(param_value) = p_form_scope {
        multipart_form_params.insert("scope", param_value.to_string());
    }
    if let Some(param_value) = p_form_refresh_token {
        multipart_form_params.insert("refresh_token", param_value.to_string());
    }
    if let Some(param_value) = p_form_client_secret {
        multipart_form_params.insert("client_secret", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::OAuth2Token`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::OAuth2Token`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<PostOAuth2TokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 自分が許可している指定したOAuthクライアントのアクセストークンを全てRevokeします。
pub async fn revoke_client_tokens(
    configuration: &configuration::Configuration,
    client_id: &str,
) -> Result<(), Error<RevokeClientTokensError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_client_id = client_id;

    let uri_str = format!(
        "{}/clients/{clientId}/tokens",
        configuration.base_path,
        clientId = crate::apis::urlencode(p_path_client_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeClientTokensError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// 自分の指定したトークンの認可を取り消します。
pub async fn revoke_my_token(
    configuration: &configuration::Configuration,
    token_id: &str,
) -> Result<(), Error<RevokeMyTokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_token_id = token_id;

    let uri_str = format!(
        "{}/users/me/tokens/{tokenId}",
        configuration.base_path,
        tokenId = crate::apis::urlencode(p_path_token_id)
    );
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeMyTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}

/// OAuth2 トークン無効化エンドポイント
pub async fn revoke_o_auth2_token(
    configuration: &configuration::Configuration,
    token: &str,
) -> Result<(), Error<RevokeOAuth2TokenError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_token = token;

    let uri_str = format!("{}/oauth2/revoke", configuration.base_path);
    let mut req_builder = configuration
        .client
        .request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("token", p_form_token.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<RevokeOAuth2TokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent {
            status,
            content,
            entity,
        }))
    }
}
